
-- 1. Create tables

-- Watchlists (User generated lists)
create table if not exists public.watchlists (
    id uuid default gen_random_uuid() primary key,
    user_id uuid references auth.users(id) on delete cascade not null,
    name text not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
create index if not exists idx_watchlists_user_id on public.watchlists(user_id);

-- Watchlist Items (Symbols in a watchlist)
create table if not exists public.watchlist_items (
    id uuid default gen_random_uuid() primary key,
    watchlist_id uuid references public.watchlists(id) on delete cascade not null,
    symbol text not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    unique(watchlist_id, symbol)
);
create index if not exists idx_watchlist_items_watchlist_id on public.watchlist_items(watchlist_id);
create index if not exists idx_watchlist_items_symbol on public.watchlist_items(symbol);

-- User Scan Settings (Configuration per user)
create table if not exists public.user_scan_settings (
    user_id uuid references auth.users(id) on delete cascade primary key,
    rsi_period int default 14,
    overbought int default 70,
    oversold int default 30,
    near_overbought_from int default 65,
    near_oversold_to int default 35,
    enable_alerts boolean default true,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Alerts (Generated by the system based on scan results)
-- Create basic table if not exists first (compatible with old versions if any)
create table if not exists public.alerts (
    id uuid default gen_random_uuid() primary key,
    user_id uuid references auth.users(id) on delete cascade not null,
    symbol text not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Add columns securely (Idempotent)
alter table public.alerts add column if not exists scan_date date;
alter table public.alerts add column if not exists rsi numeric;
alter table public.alerts add column if not exists state text; -- Constraint added separately ideally or just trust app
alter table public.alerts add column if not exists slope_5 numeric;
alter table public.alerts add column if not exists message text;
alter table public.alerts add column if not exists is_sent boolean default false;
alter table public.alerts add column if not exists sent_at timestamp with time zone;

-- Update scan_date to be not null if possible, but might fail if rows exist.
-- We skip 'not null' constraint enforcement on existing rows for safety, or we delete invalid rows.
-- delete from public.alerts where scan_date is null; 
-- alter table public.alerts alter column scan_date set not null; 

-- Log Table
create table if not exists public.jobs_log (
    id uuid default gen_random_uuid() primary key,
    job_name text not null,
    run_at timestamp with time zone default timezone('utc'::text, now()) not null,
    status text check (status in ('OK', 'FAILED')),
    meta jsonb,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Indices
create index if not exists idx_alerts_user_id on public.alerts(user_id);
create index if not exists idx_alerts_symbol on public.alerts(symbol);
create index if not exists idx_alerts_scan_date on public.alerts(scan_date);

-- RLS Policies (Drop first to avoid conflicts)

-- Watchlists
alter table public.watchlists enable row level security;
drop policy if exists "Users can view their own watchlists" on public.watchlists;
create policy "Users can view their own watchlists" on public.watchlists for select using (auth.uid() = user_id);
drop policy if exists "Users can insert their own watchlists" on public.watchlists;
create policy "Users can insert their own watchlists" on public.watchlists for insert with check (auth.uid() = user_id);
drop policy if exists "Users can update their own watchlists" on public.watchlists;
create policy "Users can update their own watchlists" on public.watchlists for update using (auth.uid() = user_id);
drop policy if exists "Users can delete their own watchlists" on public.watchlists;
create policy "Users can delete their own watchlists" on public.watchlists for delete using (auth.uid() = user_id);

-- Watchlist Items
alter table public.watchlist_items enable row level security;
drop policy if exists "Users can view items in their watchlists" on public.watchlist_items;
create policy "Users can view items in their watchlists" on public.watchlist_items for select using (
    exists (select 1 from public.watchlists w where w.id = watchlist_items.watchlist_id and w.user_id = auth.uid())
);
drop policy if exists "Users can insert items to their watchlists" on public.watchlist_items;
create policy "Users can insert items to their watchlists" on public.watchlist_items for insert with check (
    exists (select 1 from public.watchlists w where w.id = watchlist_items.watchlist_id and w.user_id = auth.uid())
);
drop policy if exists "Users can update items in their watchlists" on public.watchlist_items;
create policy "Users can update items in their watchlists" on public.watchlist_items for update using (
    exists (select 1 from public.watchlists w where w.id = watchlist_items.watchlist_id and w.user_id = auth.uid())
);
drop policy if exists "Users can delete items in their watchlists" on public.watchlist_items;
create policy "Users can delete items in their watchlists" on public.watchlist_items for delete using (
    exists (select 1 from public.watchlists w where w.id = watchlist_items.watchlist_id and w.user_id = auth.uid())
);

-- Scan Settings
alter table public.user_scan_settings enable row level security;
drop policy if exists "Users can view their own settings" on public.user_scan_settings;
create policy "Users can view their own settings" on public.user_scan_settings for select using (auth.uid() = user_id);
drop policy if exists "Users can insert their own settings" on public.user_scan_settings;
create policy "Users can insert their own settings" on public.user_scan_settings for insert with check (auth.uid() = user_id);
drop policy if exists "Users can update their own settings" on public.user_scan_settings;
create policy "Users can update their own settings" on public.user_scan_settings for update using (auth.uid() = user_id);

-- Alerts
alter table public.alerts enable row level security;
drop policy if exists "Users can view their own alerts" on public.alerts;
create policy "Users can view their own alerts" on public.alerts for select using (auth.uid() = user_id);
drop policy if exists "Users can update their own alerts" on public.alerts;
create policy "Users can update their own alerts" on public.alerts for update using (auth.uid() = user_id);

-- Jobs Log
alter table public.jobs_log enable row level security;
drop policy if exists "Service role manages jobs log" on public.jobs_log;
create policy "Service role manages jobs log" on public.jobs_log for all using (true);
